<!DOCTYPE HTML>
<html lang="en" class="steinberg-light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>[3.0.0] Multiple Dynamic I/O Support - VST 3 Developer Portal</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="shortcut icon" href="../../../../favicon.png">
        <link rel="shortcut icon" href="../../../../resources/favicon/favicon-16x16.png" type="image/png">
        <link rel="shortcut icon" href="../../../../resources/favicon/favicon-32x32.png" type="image/png">
        <link rel="shortcut icon" href="../../../../resources/favicon/favicon-192x192.png" type="image/png">
        <link rel="shortcut icon" href="../../../../resources/favicon/favicon-256x256.png" type="image/png">

        <link rel="stylesheet" href="../../../../css/variables.css">
        <link rel="stylesheet" href="../../../../css/general.css">
        <link rel="stylesheet" href="../../../../css/chrome.css">
        <link rel="stylesheet" href="../../../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../../../highlight.css">
        <link rel="stylesheet" href="../../../../tomorrow-night.css">
        <link rel="stylesheet" href="../../../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "steinberg-dark" : "steinberg-light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../../../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('steinberg-light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="steinberg-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="steinberg-dark">Dark</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">VST 3 Developer Portal</h1>

                    <div class="right-buttons">
                        <a href="../../../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/steinbergmedia/vst3_dev_portal/tree/deploy" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <blockquote>
<p>/ <a href="../../../">VST Home</a> / <a href="../../Index.html">Technical Documentation</a></p>
<h1 id="300-multiple-dynamic-io-support"><a class="header" href="#300-multiple-dynamic-io-support">[3.0.0] Multiple Dynamic I/O Support</a></h1>
</blockquote>
<p><strong>On this page:</strong></p>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#multiple-input-or-output-busses">Multiple Input or Output busses</a></li>
<li><a href="#information-about-busses">Information about busses</a></li>
<li><a href="#activation-of-busses">Activation of busses</a></li>
<li><a href="#what-is-a-side-chain">What is a Side-Chain?</a></li>
<li><a href="#how-can-i-implement-a-side-chain-path-into-my-plug-in">How can I implement a Side-chain path into my plug-in?</a></li>
<li><a href="#audio-bus-channel-configuration">Audio bus Channel Configuration</a>
<ul>
<li><a href="#how-are-the-different-speakers-located">How are the different Speakers located?</a></li>
<li><a href="#my-plug-in-is-capable-of-processing-all-possible-channel-configurations">My plug-in is capable of processing all possible channel configurations</a></li>
<li><a href="#how-are-speaker-arrangement-settings-handled-for-fx-plug-ins">How are speaker arrangement settings handled for FX plug-ins?</a></li>
<li><a href="#how-report-to-the-host-that-the-plug-in-arrangement-has-changed">How report to the host that the plug-in Arrangement has changed?</a></li>
<li><a href="#my-plug-in-has-mono-input-and-stereo-output-how-does-vst-3-handle-this">My plug-in has mono input and stereo output. How does VST 3 handle this?</a></li>
</ul>
</li>
</ul>
<p><strong>Related pages</strong></p>
<ul>
<li><a href="../../Workflow+Diagrams/Audio+Processor+Call+Sequence.html">Audio Processor Call Sequence</a></li>
<li><a href="../../Workflow+Diagrams/Bus+Arrangement+Setting+Sequence.html">Bus Arrangement Setting Sequence</a></li>
<li><a href="../../Complex+Structures/Index.html">Complex Plug-in Structures / Multi-timbral Instruments</a></li>
</ul>
<hr />
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p><strong>VST 3</strong> plug-ins are no longer limited to a fixed number of inputs and outputs, and their I/O configuration can dynamically adapt to the channel configuration. <a href="../3.0.0/Multiple+Dynamic+IO.html#what-is-a-side-chain">Side-chains</a> are also very easily realizable. This includes the possibility to deactivate unused busses after loading and even reactivate those when needed. This cleans up the mixer and further helps to reduce CPU load.</p>
<p>A <strong>bus</strong> can be understood as a "collection of data channels" belonging together:</p>
<ul>
<li>it describes a data input (<strong>kInput</strong>) or a data output (<strong>kOutput</strong>) of the plug-in.</li>
<li>2 types of bus is supported: <strong>kAudio</strong> and <strong>kEvent</strong></li>
<li>a VST component can define any desired number of busses.</li>
<li>a bus could be defined a main bus (<strong>kMain</strong>) or auxiliary bus (<strong>kAux</strong>) for sidechaining (The kMain busses have to place before any others kAux busses in the exported busses list)</li>
<li>a host that can handle multiple busses, allows the user to activate busses which are initially all inactive.</li>
</ul>
<h2 id="multiple-input-or-output-busses"><a class="header" href="#multiple-input-or-output-busses">Multiple Input or Output busses</a></h2>
<p>A plug-in could have different reason to define multiple event input busses, for examples:</p>
<ul>
<li>in case of complex multitimbral instrument supporting more than 16 loaded sub-instruments at the same time by adding a kind of structure in its inputs from host perspective (simulating a kind of number of "MIDI Port" having its sub-MIDI channels)</li>
<li>in case to different inputs meaning, which are distinctly visible and selectable in the host:
<ul>
<li>one input for playing event</li>
<li>one input for modulation event</li>
</ul>
</li>
</ul>
<p>A plug-in could have different reason to define multiple event output busses, for example:</p>
<ul>
<li>in case of a main event output for played event from the UI and one event output for internally generated events from an arpeggiator.</li>
</ul>
<p>A plug-in could decide to export more than one audio input by adding a second audio input (<a href="../3.0.0/Multiple+Dynamic+IO.html#what-is-a-side-chain">Side-chains, see below</a>) or more.</p>
<p>A typical use case for multiple audio outputs is instrument plug-ins, for examples:</p>
<ul>
<li>with one main audio output and some auxiliary audio outputs for FX Returns or FX Sends.</li>
<li>with one main audio output for each internally loaded instrument.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="language-c++">//------------------------------------------------------------------------
tresult PLUGIN_API MyPlugin::initialize (FUnknown* context)
{
    //---always initialize the parent-------
    tresult result = AudioEffect::initialize (context);
    // if everything Ok, continue
    if (result != kResultOk)
    {
        return result;
    }

    //---create Audio In/Out busses------
    // we want a stereo Input and a Stereo Output
    addAudioInput (STR16 ("Stereo In"), SpeakerArr::kStereo, kMain, BusInfo::kDefaultActive);
    addAudioOutput (STR16 ("Stereo Out"), SpeakerArr::kStereo, kMain, BusInfo::kDefaultActive);

    //---create Main Event In bus (1 bus with only 16 channel)------
    addEventInput (STR16 ("Event In"), 16, kMain, BusInfo::kDefaultActive);

    //---create Aux Event In bus (1 bus with only 1 channel)------
    addEventInput (STR16 ("Mod In"), 1, kAux, 0); // not default activated wanted

    //---create Event out bus (1 bus with only 1 channel)------
    addEventOutput (STR16 ("Arpeggiator"), 1, kAux, 0); // not default activated wanted

    return kResultOk;
}
</code></pre>
<h2 id="information-about-busses"><a class="header" href="#information-about-busses">Information about busses</a></h2>
<p>In order to get the number and information about busses exported by the plug-in, the host uses this interface <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IComponent.html">IComponent</a> with these functions:</p>
<pre><code class="language-c++">/** Called after the plug-in is initialized. */
virtual int32 PLUGIN_API getBusCount (MediaType type, BusDirection dir) = 0;
 
/** Called after the plug-in is initialized. */
virtual tresult PLUGIN_API getBusInfo (MediaType type, BusDirection dir, int32 index, BusInfo&amp; bus /*out*/) = 0;
</code></pre>
<p><strong>BusInfo</strong> contains information like:</p>
<ul>
<li>name,</li>
<li>number of channel,</li>
<li>...</li>
<li>and the some flags indicating:
<ul>
<li><strong>kDefaultActive</strong>: The bus should be activated by the host per default on instantiation (activateBus call is requested). By default a bus is inactive. Note that if a host offers the possibility to activate/deactivate busses to the user later on, it may not follow this flag kDefaultActive and let some busses deactivated on instantiation.</li>
<li><strong>kIsControlVoltage</strong>: The bus does not contain ordinary audio data, but data used for control changes at sample rate.
<ul>
<li>The data is in the same format as the audio data [-1.0, 1.0].</li>
<li>A host has to prevent unintended routing to speakers to prevent damage.</li>
<li>Only valid for audio media type busses.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="activation-of-busses"><a class="header" href="#activation-of-busses">Activation of busses</a></h2>
<p>Dynamic usage of busses is handled in the host by activating and deactivating busses. All busses are initially inactive.</p>
<p>The plug-in has to define which of them have to be activated by default after instantiation of the plug-in, this is only a wish, the host is allowed to not follow it, and only activate the first bus for example.</p>
<pre><code class="language-c++">// here default activation is wanted (but not guaranteed)
addAudioInput (STR16 ("SideChain"), SpeakerArr::kStereo, kAux, BusInfo::kDefaultActive);
</code></pre>
<p>In order to be use each Input bus and Output bus have to be activated, this is done by the host by using this interface implemented by the plug-in (<a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IComponent.html">IComponent</a>):</p>
<pre><code class="language-c++">//------------------------------------------------------------------------
tresult PLUGIN_API Component::activateBus (MediaType type, BusDirection dir, int32 index, TBool state)
{
    // ...
</code></pre>
<p>Deactivated busses do not need to be processed by the plug-in, which allows to reduce the CPU load.</p>
<p>Check the workflow diagrams in order to understand when this is called:</p>
<ul>
<li><a href="../../Workflow+Diagrams/Audio+Processor+Call+Sequence.html">Audio Processor Call Sequence</a></li>
<li><a href="../../Workflow+Diagrams/Bus+Arrangement+Setting+Sequence.html">Bus Arrangement Setting Sequence</a></li>
</ul>
<h2 id="what-is-a-side-chain"><a class="header" href="#what-is-a-side-chain">What is a Side-Chain?</a></h2>
<p>In audio applications, some plug-ins allow for a secondary signal to be made available to the plug-in and act as a controller of one or more parameters in the processing. Such a signal is commonly called a Side-chain Signal or Side-chain Input.</p>
<p><strong>Examples</strong>:</p>
<p>If a recorded kick drum is considered well played, but the recording of the bass player's part shows that he regularly plays slightly ahead of the kick drum, a plug-in with a 'Gating' function on the bass part can use the kick drum signal as a side-chain to 'trim' the bass part precisely to that of the kick.</p>
<p>Another application is to automatically lower the level of a musical background when another signal, such as a voice, reaches a certain level. In this case a plug-in with a 'Ducking' function would be used - where the main musical signal is reduced while the voice signal is applied to the side-chain input.</p>
<p>A delay's mix parameter can be controlled by a side-chain input signal - to make the amount of delay signal proportional to the level of another.</p>
<p>The side-chain can be used as an additional modulation source instead of cyclic forms of modulation. From the plug-in's perspective, side-chain inputs and/or outputs are additional inputs and outputs which can be enabled or disabled by the host.</p>
<p>The host (if supported) will provide to the user a way to route some signal paths to these side-chain inputs or from side-chain outputs to others signal inputs.</p>
<p><a href="https://www.youtube.com/watch?v=6AvqoFSk2S8"><img src="https://i.ytimg.com/vi/6AvqoFSk2S8/maxresdefault.jpg" alt="getting_started_vid_3" /></a></p>
<p>What is Side-Chaining and How to Use It | Music Production For Beginners</p>
<p><a href="https://www.youtube.com/watch?v=PBQr-PnI6Yw"><img src="https://i.ytimg.com/vi/PBQr-PnI6Yw/maxresdefault.jpg" alt="getting_started_vid_4" /></a></p>
<p>Here an example of Side-Chaining for a Instrument in Cubase</p>
<h2 id="how-can-i-implement-a-side-chain-path-into-my-plug-in"><a class="header" href="#how-can-i-implement-a-side-chain-path-into-my-plug-in">How can I implement a Side-chain path into my plug-in?</a></h2>
<p>In AudioEffect::initialize (FUnknown* context) you must add the required bus- and speaker configuration of your plug-in.
For example, if your plug-in works on one input and one output bus, both stereo, the appropriate code snippet would look in the following way:</p>
<pre><code class="language-c++">addAudioInput (USTRING ("Stereo In"), SpeakerArr::kStereo);
addAudioOutput (USTRING ("Stereo Out"), SpeakerArr::kStereo);
 
// In addition, adding a stereo side-chain bus would look in the following way:
addAudioInput (USTRING ("Aux In"), SpeakerArr::kStereo, kAux, 0); // 0 here means not activated by default wanted
</code></pre>
<h2 id="audio-bus-channel-configuration"><a class="header" href="#audio-bus-channel-configuration">Audio bus Channel Configuration</a></h2>
<p>Each audio bus has its channel configuration which is a Speaker Arrangement:</p>
<p><strong>Stereo (L+R)</strong></p>
<pre><code class="language-c++">const SpeakerArrangement kStereo = kSpeakerL | kSpeakerR;
</code></pre>
<h3 id="how-are-the-different-speakers-located"><a class="header" href="#how-are-the-different-speakers-located">How are the different Speakers located?</a></h3>
<p>Here's an overview of the main defined speaker locations (Check enum Speakers and namespace SpeakerArr). A <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/group__vst3typedef.html#ga54884a26d0b6dfa18eb919ea004775ac">SpeakerArrangement</a> is a bitset combination of speakers.</p>
<p>For example:</p>
<pre><code class="language-c++">const SpeakerArrangement kStereo = kSpeakerL | kSpeakerR; // =&gt; representing in hexadecimal 0x03 and in binary 0011.
</code></pre>
<p><img src="../../../../resources/tech_doc_28.jpg" alt="Tech_doc_28" /></p>
<h3 id="my-plug-in-is-capable-of-processing-all-possible-channel-configurations"><a class="header" href="#my-plug-in-is-capable-of-processing-all-possible-channel-configurations">My plug-in is capable of processing all possible channel configurations</a></h3>
<p>What type of speaker arrangement should I select when adding busses?</p>
<p>Take the configuration your plug-in is most likely to be used with. For a 5.1-surround setup that would be the following:</p>
<pre><code class="language-c++">addAudioInput (USTRING ("Surround In"), SpeakerArr::k51);
addAudioOutput (USTRING ("Surround Out"), SpeakerArr::k51);
</code></pre>
<p>But when the host calls <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IAudioProcessor.html#ad3bc7bac3fd3b194122669be2a1ecc42">Vst::IAudioProcessor::setBusArrangements</a> the host is informing your plug-in of the current speaker arrangement of the track it was selected in. You should return <strong>kResultOk</strong>, in the case you accept this arrangement, or <strong>kResultFalse</strong>, in case you do not.</p>
<blockquote>
<p>ⓘ <strong>Note</strong><br />
If you reject a <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IAudioProcessor.html#ad3bc7bac3fd3b194122669be2a1ecc42">Vst::IAudioProcessor::setBusArrangements</a> by returning <strong>kResultFalse</strong>, the host calls <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IAudioProcessor.html#adac76e90d4a18622d818c8204f937f94">Vst::IAudioProcessor::getBusArrangement</a> where you have the chance to give the parameter 'arrangement' the value of the speaker arrangement your plug-in does accept for this given bus.</p>
<p>Afterward the host can recall <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IAudioProcessor.html#ad3bc7bac3fd3b194122669be2a1ecc42">Vst::IAudioProcessor::setBusArrangements</a> with the plug-in wanted Arrangements then the plug-in should return <strong>kResultOk</strong>.</p>
</blockquote>
<h3 id="how-are-speaker-arrangement-settings-handled-for-fx-plug-ins"><a class="header" href="#how-are-speaker-arrangement-settings-handled-for-fx-plug-ins">How are speaker arrangement settings handled for FX plug-ins?</a></h3>
<p>After instantiation of the plug-in, the host calls <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IAudioProcessor.html#ad3bc7bac3fd3b194122669be2a1ecc42">Vst::IAudioProcessor::setBusArrangements</a> with a default configuration (depending on the current channel configuration), if the plug-in accepts it (by returning <strong>kResultOK</strong>), it will continue with this configuration.
If not (by returning <strong>kResultFalse</strong>), the host asks the plug-in for its wanted configuration by calling <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IAudioProcessor.html#adac76e90d4a18622d818c8204f937f94">Vst::IAudioProcessor::getBusArrangement</a> (for Input and Output) and then recall <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IAudioProcessor.html#ad3bc7bac3fd3b194122669be2a1ecc42">Vst::IAudioProcessor::setBusArrangements</a> with the final wanted configuration. Check <a href="../../Workflow+Diagrams/Bus+Arrangement+Setting+Sequence.html">Bus Arrangement Setting Sequences</a> workflow.</p>
<pre><code class="language-c++">// Example of a Plug-in supporting only symmetric Input-Output Arrangements:

host -&gt; plug-in: setBusArrangements (monoIN, stereoOUT)
plug-in return: kResultFalse
host -&gt; plug-in: getBusArrangement (IN) =&gt; return Stereo;
host -&gt; plug-in: getBusArrangement (OUT) =&gt; return Stereo;
host -&gt; plug-in: setBusArrangements (stereoIN, stereoOUT)
plug-in return: kResultOk
</code></pre>
<pre><code class="language-c++">// Example of a Plug-in supporting only asymmetric Input-Output Arrangements (mono-&gt;stereo):

host -&gt; plug-in: setBusArrangements (stereoIN, stereoOUT)
plug-in return: kResultFalse
host -&gt; plug-in: getBusArrangement (IN) =&gt; return Mono;
host -&gt; plug-in: getBusArrangement (OUT) =&gt; return Stereo;
host -&gt; plug-in: setBusArrangements (MonoIN, stereoOUT)
plug-in return: kResultOk
</code></pre>
<pre><code class="language-c++">// Example of a Plug-in supporting only asymmetric Input-Output Arrangements (mono-&gt; stereo to up 5.1):

host -&gt; plug-in: setBusArrangements (5.1IN, 5.1OUT)
plug-in return: kResultFalse
host -&gt; plug-in: getBusArrangement (IN) =&gt; return Mono;
host -&gt; plug-in: getBusArrangement (OUT) =&gt; return 5.1;
host -&gt; plug-in: setBusArrangements (MonoIN, 5.1OUT)
plug-in return: kResultOk
</code></pre>
<pre><code class="language-c++">// Host -&gt; Plug-in: setBusArrangements (QuadroIN, QuadroOUT)

plug-in return: kResultFalse
host -&gt; plug-in: getBusArrangement (IN) =&gt; return Mono;
host -&gt; plug-in: getBusArrangement (OUT) =&gt; return Quadro;
host -&gt; plug-in: setBusArrangements (MonoIN, QuadroOUT)
plug-in return: kResultOk
</code></pre>
<pre><code class="language-c++">// Example of a Plug-in supporting only symmetric Input-Output Arrangements and Side-chain Input always mono:

host -&gt; plug-in: getBusArrangements (IN) =&gt; Input Main:Mono / Input Side-chain:Mono
host -&gt; plug-in: getBusArrangements (OUT) =&gt; Output: mono
host -&gt; plug-in: setBusArrangements (Input Main:stereo / Input Side-chain:Mono, Output: stereo)
plug-in return: kResultTrue

or
host -&gt; plug-in: getBusArrangements (IN) =&gt; Input Main:Mono / Input Side-chain:Mono
host -&gt; plug-in: getBusArrangements (OUT) =&gt; Output: mono
host -&gt; plug-in: setBusArrangements (Input Main:stereo / Input Side-chain:stereo, Output: stereo)
plug-in return: kResultFalse // because we want mono for Side-chain
host -&gt; plug-in: getBusArrangement (IN) =&gt; return Input Main:stereo / Input Side-chain:mono;
host -&gt; plug-in: getBusArrangement (OUT) =&gt; return Stereo;
host -&gt; plug-in: setBusArrangements (Input Main:stereo / Input Side-chain:mono, Output: stereo)
plug-in return: kResultOk
</code></pre>
<pre><code class="language-c++">// Example of a Plug-in supporting only symmetric Input-Output Arrangements and Side-chain Input following the Main Input Arrangement:

host -&gt; plug-in: getBusArrangements (IN) =&gt; Input Main:Mono / Input Side-chain:Mono
host -&gt; plug-in: getBusArrangements (OUT) =&gt; Output: mono
host -&gt; plug-in: setBusArrangements (Input Main:stereo / Input Side-chain:Mono, Output: stereo)
plug-in return: kResultFalse // because we want the same arrangement for Input Main and Side-chain
host -&gt; plug-in: getBusArrangement (IN) =&gt; return Input Main:stereo / Input Side-chain:stereo;
host -&gt; plug-in: getBusArrangement (OUT) =&gt; return Stereo;
host -&gt; plug-in: setBusArrangements (Input Main:stereo / Input Side-chain:stereo, Output: stereo)
plug-in return: kResultOk
</code></pre>
<h3 id="how-report-to-the-host-that-the-plug-in-arrangement-has-changed"><a class="header" href="#how-report-to-the-host-that-the-plug-in-arrangement-has-changed">How report to the host that the plug-in Arrangement has changed?</a></h3>
<p>When loading a preset or with an user interaction, the plug-in wants to change its IO configuration. In this case the plug-in should call from the editController its component handler with flag kIoChanged:</p>
<pre><code class="language-c++">componentHandler-&gt;restartComponent (kIoChanged);
</code></pre>
<p>The host will call <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IAudioProcessor.html#adac76e90d4a18622d818c8204f937f94">Vst::IAudioProcessor::getBusArrangement</a> (for Input and Output) in order to check the new requested arrangement and then the host will call <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IAudioProcessor.html#ad3bc7bac3fd3b194122669be2a1ecc42">Vst::IAudioProcessor::setBusArrangements</a> (called in suspend state: <a href="https://steinbergmedia.github.io/vst3_doc/vstinterfaces/classSteinberg_1_1Vst_1_1IComponent.html#a0a840e8077eb74ec429b8007c7b83517">setActive</a> (false)) to confirm the requested arrangement.</p>
<h3 id="my-plug-in-has-mono-input-and-stereo-output-how-does-vst-3-handle-this"><a class="header" href="#my-plug-in-has-mono-input-and-stereo-output-how-does-vst-3-handle-this">My plug-in has mono input and stereo output. How does VST 3 handle this?</a></h3>
<p>There are two ways to instantiate a plug-in in the following way:</p>
<ul>
<li><strong>Way 1</strong></li>
</ul>
<p>In AudioEffect::initialize (FUnknown* context) you add one mono and one stereo bus.</p>
<pre><code class="language-c++">//---------------------------------------------------------------
tresult PLUGIN_API AGain::initialize (FUnknown* context)
{
    //---always initialize the parent-------
    tresult result = AudioEffect::initialize (context);
    // if everything Ok, continue
    if (result != kResultOk)
    {
        return result;
    }

    addAudioInput (USTRING ("Mono In"), SpeakerArr::kMono);
    addAudioOutput (USTRING ("Stereo Out"), SpeakerArr::kStereo);
    //...
</code></pre>
<p>In case of <strong>Cubase/Nuendo</strong> being the host, the plug-in, afterbeing inserted into a stereo track, gets the left channel ofthe stereo input signal as its mono input. From this signalyou can create a stereo output signal.</p>
<ul>
<li><strong>Way 2</strong></li>
</ul>
<p>In <a href="https://steinbergmedia.github.io/vst3_doc/vstsdk/classSteinberg_1_1Vst_1_1AudioEffect.html">AudioEffect</a>::initialize (FUnknown* context) you add one stereo input and one stereo output bus.</p>
<pre><code class="language-c++">//---------------------------------------------------------------
tresult PLUGIN_API AGain::initialize (FUnknown* context)
{
    //---always initialize the parent-------
    tresult result = AudioEffect::initialize (context);
    // if everything Ok, continue
    if (result != kResultOk)
    {
        return result;
    }

    addAudioInput (USTRING ("Stereo In"), SpeakerArr::kStereo);
    addAudioOutput (USTRING ("Stereo Out"), SpeakerArr::kStereo);
    //...
</code></pre>
<p>For processing, the algorithm of your plug-in takes the left channel only, or creates a new mono input signal, by adding the samples of the left and right channels.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../../../pages/Technical+Documentation/Change+History/3.0.0/Plug+in+Interfaces.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../../../pages/Technical+Documentation/Change+History/3.0.0/Silence+flags.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>

            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../../../pages/Technical+Documentation/Change+History/3.0.0/Plug+in+Interfaces.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../../../pages/Technical+Documentation/Change+History/3.0.0/Silence+flags.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>
            
            <div id="footer" class="footer">
                <!-- Here comes the footer when available -->
                © 2024 <a href="https://www.steinberg.net" target="_blank">Steinberg Media Technologies GmbH</a>.&nbsp; All rights reserved.&nbsp;&nbsp;&nbsp;&nbsp;
                <a href="https://o.steinberg.net/en/extras/about.html" target="_blank">About</a> |
                <a href="https://o.steinberg.net/en/extras/privacy_policy.html" target="_blank">Privacy Policy</a> |
                <a href="https://o.steinberg.net/en/extras/terms_conditions.html" target="_blank">Legal Terms</a> 
            </div>
        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../../../elasticlunr.min.js"></script>
        <script src="../../../../mark.min.js"></script>
        <script src="../../../../searcher.js"></script>

        <script src="../../../../clipboard.min.js"></script>
        <script src="../../../../highlight.js"></script>
        <script src="../../../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../../../mermaid.min.js"></script>
        <script src="../../../../mermaid-init.js"></script>


    </div>
    </body>
</html>
