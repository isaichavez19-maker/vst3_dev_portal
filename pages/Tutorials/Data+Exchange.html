<!DOCTYPE HTML>
<html lang="en" class="steinberg-light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Data Exchange - VST 3 Developer Portal</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="shortcut icon" href="../../resources/favicon/favicon-16x16.png" type="image/png">
        <link rel="shortcut icon" href="../../resources/favicon/favicon-32x32.png" type="image/png">
        <link rel="shortcut icon" href="../../resources/favicon/favicon-192x192.png" type="image/png">
        <link rel="shortcut icon" href="../../resources/favicon/favicon-256x256.png" type="image/png">

        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "steinberg-dark" : "steinberg-light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('steinberg-light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="steinberg-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="steinberg-dark">Dark</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">VST 3 Developer Portal</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/steinbergmedia/vst3_dev_portal/tree/deploy" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <blockquote>
<p>/ <a href="../">VST Home</a> / <a href="Index.html">Tutorials</a></p>
<h1 id="data-exchange-tutorial---how-to-send-data-from-the-realtime-process-to-the-edit-controller"><a class="header" href="#data-exchange-tutorial---how-to-send-data-from-the-realtime-process-to-the-edit-controller">Data Exchange Tutorial - How to send data from the realtime process to the edit controller</a></h1>
</blockquote>
<p><strong>On this page:</strong></p>
<ul>
<li><a href="#tutorial---how-to-use-the-data-exchange-api">Tutorial - How to use the Data Exchange API</a>
<ul>
<li><a href="#sending-data-from-the-audio-processor">Sending data from the audio processor</a></li>
<li><a href="#receiving-data-in-the-edit-controller">Receiving data in the edit controller</a></li>
</ul>
</li>
</ul>
<p><strong>Related pages:</strong></p>
<ul>
<li><a href="../Technical+Documentation/Data+Exchange/Index.html">Data Exchange</a></li>
</ul>
<hr />
<blockquote>
<p>You'll find the source for this tutorial in the <a href="https://github.com/steinbergmedia/vst3_tutorials/blob/master/dataexchange-tutorial">tutorial repository</a></p>
</blockquote>
<h2 id="tutorial---how-to-use-the-data-exchange-api"><a class="header" href="#tutorial---how-to-use-the-data-exchange-api">Tutorial - How to use the Data Exchange API</a></h2>
<p>In this tutorial you learn how to use the <em>Data Exchange API</em> to send data from the realtime audio
process method to the edit controller of your plug-in.</p>
<h3 id="sending-data-from-the-audio-processor"><a class="header" href="#sending-data-from-the-audio-processor">Sending data from the audio processor</a></h3>
<p>Let's send data from the processor to the controller.</p>
<p>First, we need to add the required include so that we can use the wrapper class. Add the following
include before you define your audio processor:</p>
<pre><code class="language-c++">#include "public.sdk/source/vst/utility/dataexchange.h"
</code></pre>
<p>To prepare the AudioEffect class, you need to overwrite the following methods:</p>
<pre><code class="language-c++">tresult PLUGIN_API initialize (FUnknown* context) override;
tresult PLUGIN_API connect (Vst::IConnectionPoint* other) override;
tresult PLUGIN_API disconnect (Vst::IConnectionPoint* other) override;
tresult PLUGIN_API setActive (TBool state) override;
tresult PLUGIN_API canProcessSampleSize (int32 symbolicSampleSize) override;
tresult PLUGIN_API process (Vst::ProcessData&amp; data) override;
</code></pre>
<p>And we also have to add the wrapper class as a member of our audio processor class:</p>
<pre><code class="language-c++">std::unique_ptr&lt;Vst::DataExchangeHandler&gt; dataExchange;
</code></pre>
<p>Now we can initialize and configure the dataExchange. We do this in:</p>
<pre><code class="language-c++">tresult PLUGIN_API DataExchangeProcessor::connect (Vst::IConnectionPoint* other)
{
    auto result = Vst::AudioEffect::connect (other);
    if (result == kResultTrue)
    {
        auto configCallback = [this] (Vst::DataExchangeHandler::Config&amp; config,
                                      const Vst::ProcessSetup&amp; setup) {
            Vst::SpeakerArrangement arr;
            getBusArrangement (Vst::BusDirections::kInput, 0, arr);
            numChannels = static_cast&lt;uint16_t&gt; (Vst::SpeakerArr::getChannelCount (arr));
            auto sampleSize = sizeof (float);

            config.blockSize = setup.sampleRate * numChannels * sampleSize + sizeof (DataBlock);
            config.numBlocks = 2;
            config.alignment = 32;
            config.userContextID = 0;
            return true;
        };

        dataExchange = std::make_unique&lt;Vst::DataExchangeHandler&gt; (this, configCallback);
        dataExchange-&gt;onConnect (other, getHostContext ());
    }
    return result;
}
</code></pre>
<p>The configration is done via the <code>configCallback</code>. In this example, we configure the queue to have
a block size to store exactly 1 second of audio data of all the channels of the configured speaker
arrangement of the input bus. We choose two for <code>numBlocks</code> because we send one block per second,
and in this case, two blocks should be enough. If the frequency you need to send the block is higher,
you need to increase this value to prevent data drop outs.
The <code>configCallback</code> is called when the audio processor is activated.</p>
<p>The next thing we have to do is to call the dataExchange object when the edit controller is disconnected
and release the memory:</p>
<pre><code class="language-c++">tresult PLUGIN_API DataExchangeProcessor::disconnect (Vst::IConnectionPoint* other)
{
    if (dataExchange)
    {
        dataExchange-&gt;onDisconnect (other);
        dataExchange.reset ();
    }
    return AudioEffect::disconnect (other);
}
</code></pre>
<p>And we also have to call the dataExchange object when the processor's state changes:</p>
<pre><code class="language-c++">tresult PLUGIN_API DataExchangeProcessor::setActive (TBool state)
{
    if (state)
        dataExchange-&gt;onActivate (processSetup);
    else
        dataExchange-&gt;onDeactivate ();
    return AudioEffect::setActive (state);
}
</code></pre>
<p>Now we prepare the data that we want to send to the controller. To make this a little bit easier we
define a struct how this data should look like and move this into its own header "<em>dataexchange.h</em>":</p>
<pre><code class="language-c++">// dataexchange.h

#pragma once

#include "public.sdk/source/vst/utility/dataexchange.h"
#include &lt;cstdint&gt;

namespace Steinberg::Tutorial {

struct DataBlock
{
    uint32_t sampleRate;
    uint16_t sampleSize;
    uint16_t numChannels;
    uint32_t numSamples;
    float samples[0];
};

} // Steinberg::Tutorial
</code></pre>
<p>So, we want to send the sample rate, size, the number of channels and the number of samples plus
the actual samples to the controller.</p>
<p>To actually work with this <code>DataBlock</code> struct, we introduce a little helper function that we also add to
this header:</p>
<pre><code class="language-c++">inline DataBlock* toDataBlock (const Vst::DataExchangeBlock&amp; block)
{
    if (block.blockID != Vst::InvalidDataExchangeBlockID)
        return reinterpret_cast&lt;DataBlock*&gt; (block.data);
    return nullptr;
}
</code></pre>
<p>One thing remains to be done before we can start sending the data: We need a
member variable of the Vst::DataExchangeBlock struct where we store the actual block we work with
while processing the audio. So we add this to our processor definition:</p>
<pre><code class="language-c++">class DataExchangeProcessor : public Vst::AudioEffect
{
private:
    Vst::DataExchangeBlock currentExchangeBlock {InvalidDataExchangeBlock};
}
</code></pre>
<p>Now let's start to implement the processing:</p>
<pre><code class="language-c++">tresult PLUGIN_API DataExchangeProcessor::process (Vst::ProcessData&amp; processData)
{
    if (processData.numSamples &lt;= 0)
        return kResultTrue;
    return kResultTrue;
}
</code></pre>
<p>When there are no samples in the <code>processData</code> we jump out of the method directly.</p>
<p>Now the first thing we need to do is to acquire a new block from the <code>dataExchange</code> object:</p>
<pre><code class="language-c++">tresult PLUGIN_API DataExchangeProcessor::process (Vst::ProcessData&amp; processData)
{
    // ...
    if (currentExchangeBlock.blockID == Vst::InvalidDataExchangeBlockID)
        acquireNewExchangeBlock ();
    // ...
}
</code></pre>
<p>We only want to acquire a new block if we have not already done so. Therefore, we need to check this before we
call the <code>acquireNewExchangeBlock</code> method that does this:</p>
<pre><code class="language-c++">void DataExchangeProcessor::acquireNewExchangeBlock ()
{
    currentExchangeBlock = dataExchange-&gt;getCurrentOrNewBlock ();
    if (auto block = toDataBlock (currentExchangeBlock))
    {
        block-&gt;sampleRate = static_cast&lt;uint32_t&gt; (processSetup.sampleRate);
        block-&gt;numChannels = numChannels;
        block-&gt;sampleSize = sizeof (float);
        block-&gt;numSamples = 0;
    }
}
</code></pre>
<p>We ask the <code>dataExchange</code> object for a new block with <code>getCurrentOrNewBlock ()</code>, check if it is valid
with a call to the previously defined function <code>toDataBlock</code> and fill it with the sample rate, the
sample size and the number of channels.</p>
<p>Now back to our process function. We now write the samples from the input buffer into our block until
the block is filled with 1 second of audio data:</p>
<pre><code class="language-c++">tresult PLUGIN_API DataExchangeProcessor::process (Vst::ProcessData&amp; processData)
{
    // ...
    auto input = processData.inputs[0];
    auto output = processData.outputs[0];

    if (auto block = toDataBlock (currentExchangeBlock))
    {
        auto numSamples = static_cast&lt;uint32&gt; (processData.numSamples);
        while (numSamples &gt; 0)
        {
            uint32 numSamplesFreeInBlock = block-&gt;sampleRate - block-&gt;numSamples;
            uint32 numSamplesToCopy = std::min&lt;uint32&gt; (numSamplesFreeInBlock, numSamples);
            for (auto channel = 0; channel &lt; input.numChannels; ++channel)
            {
                auto blockChannelData = &amp;block-&gt;samples[0] + block-&gt;numSamples;
                auto inputChannel =
                    input.channelBuffers32[channel] + (processData.numSamples - numSamples);
                memcpy (blockChannelData, inputChannel, numSamplesToCopy * sizeof (float));
            }
            block-&gt;numSamples += numSamplesToCopy;
            if (block-&gt;numSamples == block-&gt;sampleRate)
            {
                dataExchange-&gt;sendCurrentBlock ();
                acquireNewExchangeBlock ();
                block = toDataBlock (currentExchangeBlock);
                if (block == nullptr)
                    break;
            }
            numSamples -= numSamplesToCopy;
        }
    }
    // ...
}
</code></pre>
<p>When it is filled with 1 second of audio data we send the block with <code>dataExchange-&gt;sendCurrentBlock()</code>
and directly acquire a new block afterwards.</p>
<p>Finally, we need to copy back the input audio buffers to the output audio buffers. The whole method
looks like this then:</p>
<pre><code class="language-c++">tresult PLUGIN_API DataExchangeProcessor::process (Vst::ProcessData&amp; processData)
{
    if (processData.numSamples &lt;= 0)
        return kResultTrue;

    if (currentExchangeBlock.blockID == Vst::InvalidDataExchangeBlockID)
        acquireNewExchangeBlock ();

    auto input = processData.inputs[0];
    auto output = processData.outputs[0];

    if (auto block = toDataBlock (currentExchangeBlock))
    {
        auto numSamples = static_cast&lt;uint32&gt; (processData.numSamples);
        while (numSamples &gt; 0)
        {
            uint32 numSamplesFreeInBlock = block-&gt;sampleRate - block-&gt;numSamples;
            uint32 numSamplesToCopy = std::min&lt;uint32&gt; (numSamplesFreeInBlock, numSamples);
            for (auto channel = 0; channel &lt; input.numChannels; ++channel)
            {
                auto blockChannelData = &amp;block-&gt;samples[0] + block-&gt;numSamples;
                auto inputChannel =
                    input.channelBuffers32[channel] + (processData.numSamples - numSamples);
                memcpy (blockChannelData, inputChannel, numSamplesToCopy * sizeof (float));
            }
            block-&gt;numSamples += numSamplesToCopy;
            if (block-&gt;numSamples == block-&gt;sampleRate)
            {
                dataExchange-&gt;sendCurrentBlock ();
                acquireNewExchangeBlock ();
                block = toDataBlock (currentExchangeBlock);
                if (block == nullptr)
                    break;
            }
            numSamples -= numSamplesToCopy;
        }
    }
    for (auto channel = 0; channel &lt; input.numChannels; ++channel)
    {
        if (output.channelBuffers32[channel] != input.channelBuffers32[channel])
        {
            memcpy (output.channelBuffers32[channel], input.channelBuffers32[channel],
                    processData.numSamples * sizeof (float));
        }
        output.silenceFlags = input.silenceFlags;
    }

    return kResultOk;
}
</code></pre>
<h3 id="receiving-data-in-the-edit-controller"><a class="header" href="#receiving-data-in-the-edit-controller">Receiving data in the edit controller</a></h3>
<p>We prepare our edit controller by adding the inheritance of Vst::IDataExchangeReceiver and by
providing a few methods and adding a new Vst::DataExchangeReceiverHandler member:</p>
<pre><code class="language-c++">class DataExchangeController : public Vst::EditControllerEx1,
                               public Vst::IDataExchangeReceiver
{
public:
    // ...
    tresult PLUGIN_API notify (Vst::IMessage* message) override;
    void PLUGIN_API queueOpened (Vst::DataExchangeUserContextID userContextID,
                                 uint32 blockSize,
                                 TBool&amp; dispatchOnBackgroundThread) override;
    void PLUGIN_API queueClosed (Vst::DataExchangeUserContextID userContextID) override;
    void PLUGIN_API onDataExchangeBlocksReceived (Vst::DataExchangeUserContextID userContextID, 
                                                  uint32 numBlocks,
                                                  Vst::DataExchangeBlock* blocks, 
                                                  TBool onBackgroundThread) override;

    DEFINE_INTERFACES
        DEF_INTERFACE (Vst::IDataExchangeReceiver)
    END_DEFINE_INTERFACES (EditController)
    DELEGATE_REFCOUNT (EditController)
private:
    Vst::DataExchangeReceiverHandler dataExchange {this};
}
</code></pre>
<p>First, we need to forward messages to the <code>DataExchangeReceiverHandler</code> so that it can process the
data exchange messages in case the host does not support the native API:</p>
<pre><code class="language-c++">tresult PLUGIN_API DataExchangeController::notify (Vst::IMessage* message)
{
    if (dataExchange.onMessage (message))
        return kResultTrue;
    return EditControllerEx1::notify (message);
}
</code></pre>
<p>In the next step, we can implement the <code>IDataExchangeReceiver</code> methods:</p>
<pre><code class="language-c++">void PLUGIN_API DataExchangeController::queueOpened (Vst::DataExchangeUserContextID userContextID,
                                                     uint32 blockSize,
                                                     TBool&amp; dispatchOnBackgroundThread)
{
    FDebugPrint ("Data Exchange Queue opened.\n");
}

void PLUGIN_API DataExchangeController::queueClosed (Vst::DataExchangeUserContextID userContextID)
{
    FDebugPrint ("Data Exchange Queue closed.\n");
}

void PLUGIN_API DataExchangeController::onDataExchangeBlocksReceived (
    Vst::DataExchangeUserContextID userContextID, uint32 numBlocks, Vst::DataExchangeBlock* blocks,
    TBool onBackgroundThread)
{
    for (auto index = 0u; index &lt; numBlocks; ++index)
    {
        auto dataBlock = toDataBlock (blocks[index]);
        FDebugPrint (
            "Received Data Block: SampleRate: %d, SampleSize: %d, NumChannels: %d, NumSamples: %d\n",
            dataBlock-&gt;sampleRate, static_cast&lt;uint32_t&gt; (dataBlock-&gt;sampleSize),
            static_cast&lt;uint32_t&gt; (dataBlock-&gt;numChannels),
            static_cast&lt;uint32_t&gt; (dataBlock-&gt;numSamples));
    }
}
</code></pre>
<p>The <code>onDataExchangeBlocksReceived()</code> method will be called each time the processor has sent a block.
You can now do whatever you want with the data.</p>
<p>If you want the data to be dispatched on a background thread you need to set the
<code>dispatchOnBackgroundThread</code> variable to true in the <code>queueOpened</code> method.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../pages/Tutorials/Use+VSTGUI+to+design+a+UI.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../pages/Tutorials/Advanced+VST+3+techniques.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>

            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../pages/Tutorials/Use+VSTGUI+to+design+a+UI.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../pages/Tutorials/Advanced+VST+3+techniques.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>
            
            <div id="footer" class="footer">
                <!-- Here comes the footer when available -->
                Â© 2024 <a href="https://www.steinberg.net" target="_blank">Steinberg Media Technologies GmbH</a>.&nbsp; All rights reserved.&nbsp;&nbsp;&nbsp;&nbsp;
                <a href="https://o.steinberg.net/en/extras/about.html" target="_blank">About</a> |
                <a href="https://o.steinberg.net/en/extras/privacy_policy.html" target="_blank">Privacy Policy</a> |
                <a href="https://o.steinberg.net/en/extras/terms_conditions.html" target="_blank">Legal Terms</a> 
            </div>
        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../mermaid.min.js"></script>
        <script src="../../mermaid-init.js"></script>


    </div>
    </body>
</html>
