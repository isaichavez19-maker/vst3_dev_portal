<!DOCTYPE HTML>
<html lang="en" class="steinberg-light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Advanced VST 3 techniques - VST 3 Developer Portal</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="shortcut icon" href="../../resources/favicon/favicon-16x16.png" type="image/png">
        <link rel="shortcut icon" href="../../resources/favicon/favicon-32x32.png" type="image/png">
        <link rel="shortcut icon" href="../../resources/favicon/favicon-192x192.png" type="image/png">
        <link rel="shortcut icon" href="../../resources/favicon/favicon-256x256.png" type="image/png">

        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "steinberg-dark" : "steinberg-light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('steinberg-light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="steinberg-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="steinberg-dark">Dark</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">VST 3 Developer Portal</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <blockquote>
<p>/ <a href="../">VST Home</a> / <a href="Index.html">Tutorials</a></p>
<h1 id="advanced-vst-3-techniques"><a class="header" href="#advanced-vst-3-techniques">Advanced VST 3 techniques</a></h1>
</blockquote>
<p><strong>On this page:</strong></p>
<ul>
<li><a href="#part-1-sample-accurate-parameter-handling">Part 1: Sample-accurate parameter handling</a></li>
<li><a href="#part-2-adding-32-and-64-bit-audio-processing">Part 2: Adding 32 and 64 bit audio processing</a></li>
<li><a href="#part-3-thread-safe-state-changes">Part 3: Thread safe state changes</a></li>
</ul>
<hr />
<blockquote>
<p>You'll find the source for this tutorial in the <a href="https://github.com/steinbergmedia/vst3_tutorials/blob/master/advanced-techniques-tutorial">tutorial repository</a></p>
</blockquote>
<p>In this tutorial, you will learn:</p>
<ul>
<li>How to add nearly sample-accurate parameter changes to an audio effect</li>
<li>How to use C++ templates to write one algorithm supporting 32 bit and 64 bit audio processing</li>
<li>How to set the state of the audio effect in a thread safe manner</li>
</ul>
<hr />
<h2 id="part-1-sample-accurate-parameter-handling"><a class="header" href="#part-1-sample-accurate-parameter-handling">Part 1: Sample-accurate parameter handling</a></h2>
<p>We will start by looking at this process function:</p>
<pre><code class="language-c++">void MyEffect::process (ProcessData&amp; data)
{
    handleParameterChanges (data.inputParameterChanges);

    // get the gain value for this block
    ParamValue gain = gainParameter.getValue ();

    // process audio
    AudioBusBuffers* inputs = data.inputs;
    AudioBusBuffers* outputs = data.outputs;
    for (auto channelIndex = 0; channelIndex &lt; inputs[0].numChannels; ++channelIndex)
    {
        for (auto sampleIndex = 0; sampleIndex &lt; data.numSamples; ++sampleIndex)
        {
            auto sample = inputs[0].channelBuffers32[channelIndex][sampleIndex];
            outputs[0].channelBuffers32[channelIndex][sampleIndex] = sample * gain;
        }
    }
}
</code></pre>
<p>This is straightforward and simple, we handle the parameter changes in the function <em>handleParameterChanges</em>, which we will see in a moment. Then we get the last gain parameter value and iterate over the input buffers and copy the samples from there to the output buffers before applying the <em>gain</em> factor.</p>
<p>If we look at the handleParameterChanges function:</p>
<pre><code class="language-c++">void MyEffect::handleParameterChanges (IParameterChanges*changes)
{
    if (!changes)
        return;
    int32 changeCount = changes-&gt;getParameterCount ();
    for (auto i = 0; i &lt; changeCount; ++i)
    {
        if (auto queue = changes-&gt;getParameterData (i))
        {
            auto paramID = queue-&gt;getParameterId ();
            if (paramID == ParameterID::Gain)
            {
                int32 pointCount = queue-&gt;getPointCount ();
                if (pointCount &gt; 0)
                {
                    int32 sampleOffset;
                    ParamValue value;
                    if (queue-&gt;getPoint (pointCount - 1, sampleOffset, value) == kResultTrue)
                        gainParameter.setValue (value);
                }
            }
        }
    }
}
</code></pre>
<p>We see that the <em>Gain</em> parameter only uses the last point for the gain value.</p>
<p>If we now want to use all points of the <em>Gain</em> parameter, we can use two utility classes from the SDK.</p>
<p>The first one is the <em>ProcessDataSlicer</em> which slices the audio block into smaller pieces.</p>
<pre><code class="language-c++">void MyEffect::process (ProcessData&amp; data)
{
    handleParameterChanges (data.inputParameterChanges);

    ProcessDataSlicer slicer (8);
    
    auto doProcessing = [this] (ProcessData&amp; data) {
        // get the gain value for this block
        ParamValue gain = gainParameter.getValue ();

        // process audio
        AudioBusBuffers* inputs = data.inputs;
        AudioBusBuffers* outputs = data.outputs;
        for (auto channelIndex = 0; channelIndex &lt; inputs[0].numChannels; ++channelIndex)
        {
            for (auto sampleIndex = 0; sampleIndex &lt; data.numSamples; ++sampleIndex)
            {
                auto sample = inputs[0].channelBuffers32[channelIndex][sampleIndex];
                outputs[0].channelBuffers32[channelIndex][sampleIndex] = sample * gain;
            }
        }
    }
    
    slicer.process&lt;SymbolicSampleSizes::kSample32&gt; (data, doProcessing);
}
</code></pre>
<p>As you see, we have moved the algorithm part into a lambda <em>doProcessing</em> which is passed to <em>slicer.process</em>. This lambda is now called multiple times with a maximum of 8 samples per call until the whole buffer is processed. This doesn't give us yet a better parameter resolution, but we can now use the second utility class to handle this.</p>
<p>At first, we now look at the type of the <em>gainParameter</em> variable, as this is our next utility class:</p>
<pre><code class="language-c++">SampleAccurate::Parameter gainParameter;
</code></pre>
<p>We have to change the <em>handleParameterChanges</em> function to:</p>
<pre><code class="language-c++">void MyEffect::handleParameterChanges (IParameterChanges*inputParameterChanges)
{
    int32 changeCount = inputParameterChanges-&gt;getParameterCount ();
    for (auto i = 0; i &lt; changeCount; ++i)
    {
        if (auto queue = changes-&gt;getParameterData (i))
        {
            auto paramID = queue-&gt;getParameterId ();
            if (paramID == ParameterID::Gain)
            {
                gainParameter.beginChanges (queue);
            }
        }
    }
    
}
</code></pre>
<p>in order to delegate the handling of the parameter changes to the <em>gainParameter</em> object.</p>
<p>Now we just need another small change in the process lambda to use the nearly sample-accurate <em>gain</em> value. We have to call the <em>gainParameter</em> object to <em>advance</em> the parameter value:</p>
<pre><code class="language-c++">auto doProcessing = [this] (ProcessData&amp; data) {
    // get the gain value for this block
    ParamValue gain = gainParameter.advance (data.numSamples);

    // process audio
    AudioBusBuffers* inputs = data.inputs;
    AudioBusBuffers* outputs = data.outputs;
    for (auto channelIndex = 0; channelIndex &lt; inputs[0].numChannels; ++channelIndex)
    {
        for (auto sampleIndex = 0; sampleIndex &lt; data.numSamples; ++sampleIndex)
        {
            auto sample = inputs[0].channelBuffers32[channelIndex][sampleIndex];
            outputs[0].channelBuffers32[channelIndex][sampleIndex] = sample * gain;
        }
    }
}
</code></pre>
<p>Finally, we have to do some cleanup of the <em>gainParameter</em> at the end of the <em>process</em> function by calling <em>gainParameter.endChanges</em>.</p>
<pre><code class="language-c++">void MyEffect::process (ProcessData&amp; data)
{
    handleParameterChanges (data.inputParameterChanges);

    ProcessDataSlicer slicer (8);
    
    auto doProcessing = [this] (ProcessData&amp; data) {
        // get the gain value for this block
        ParamValue gain = gainParameter.advance (data.numSamples);

        // process audio
        AudioBusBuffers* inputs = data.inputs;
        AudioBusBuffers* outputs = data.outputs;
        for (auto channelIndex = 0; channelIndex &lt; inputs[0].numChannels; ++channelIndex)
        {
            for (auto sampleIndex = 0; sampleIndex &lt; data.numSamples; ++sampleIndex)
            {
                auto sample = inputs[0].channelBuffers32[channelIndex][sampleIndex];
                outputs[0].channelBuffers32[channelIndex][sampleIndex] = sample * gain;
            }
        }
    }
    
    slicer.process&lt;SymbolicSampleSizes::kSample32&gt; (data, doProcessing);
    
    gainParameter.endChanges ();
}
</code></pre>
<p>Now, we have nearly sample-accurate parameter changes support in this example. At intervals of eight samples, the <em>gain</em> parameter will be updated to the correct value.</p>
<p>It's very simple to make this 100% sample-accurate, check out the <strong>AGain Sample Accurate</strong> example in the SDK.</p>
<hr />
<h2 id="part-2-adding-32-and-64-bit-audio-processing"><a class="header" href="#part-2-adding-32-and-64-bit-audio-processing">Part 2: Adding 32 and 64 bit audio processing</a></h2>
<p>The example currently only supports 32 bit processing. Now we will add 64 bit processing.</p>
<p>As you may have noticed above, the <em>ProcessDataSlicer</em> uses a template parameter for its process function. This template parameter <em>SampleSize</em> defines the bit depth of the audio buffers in the <em>ProcessData</em> structure. This is currently hard-coded to be <em>SymbolicSampleSizes::kSample32</em>.</p>
<p>In order to support <em>SymbolicSampleSizes::kSample64</em> we only have to make a few changes to the code. First, we adopt the algorithm part by introducing a new templated method to our effect:</p>
<pre><code class="language-c++">template &lt;SymbolicSampleSizes SampleSize&gt;
void MyEffect::process (ProcessData&amp; data)
{
}
</code></pre>
<p>We mostly just move the code from the original process method to this one, except the code for handling parameter changes:</p>
<pre><code class="language-c++">template &lt;SymbolicSampleSizes SampleSize&gt;
void MyEffect::process (ProcessData&amp; data)
{
    ProcessDataSlicer slicer (8);
    
    auto doProcessing = [this] (ProcessData&amp; data) {
        // get the gain value for this block
        ParamValue gain = gainParameter.advance (data.numSamples);

        // process audio
        AudioBusBuffers* inputs = data.inputs;
        AudioBusBuffers* outputs = data.outputs;
        for (auto channelIndex = 0; channelIndex &lt; inputs[0].numChannels; ++channelIndex)
        {
            for (auto sampleIndex = 0; sampleIndex &lt; data.numSamples; ++sampleIndex)
            {
                auto sample = inputs[0].channelBuffers32[channelIndex][sampleIndex];
                outputs[0].channelBuffers32[channelIndex][sampleIndex] = sample * gain;
            }
        }
    }
    
    slicer.process&lt;SampleSize&gt; (data, doProcessing);
}
</code></pre>
<p>We just change the template parameter <em>SampleSize</em> of the process method of the <em>ProcessDataSlicer</em> to use the same template parameter as in our own process function.</p>
<p>This will not work correctly yet, as we still work with the 32 bit audio buffers in our <em>doProcessing</em> lambda. In order to fix this, we have to introduce two more templated functions <em>getChannelBuffers</em> that will choose the correct audio buffers depending on the <em>SampleSize</em> template parameter, which can either be <em>SymbolicSampleSizes::kSample32</em> or <em>SymbolicSampleSizes::kSample64</em>:</p>
<pre><code class="language-c++">template &lt;SymbolicSampleSizes SampleSize,
        typename std::enable_if&lt;SampleSize == SymbolicSampleSizes::kSample32&gt;::type* = nullptr&gt;
inline Sample32** getChannelBuffers (AudioBusBuffers&amp; buffer)
{
    return buffer.channelBuffers32;
}

template &lt;SymbolicSampleSizes SampleSize,
        typename std::enable_if&lt;SampleSize == SymbolicSampleSizes::kSample64&gt;::type* = nullptr&gt;
inline Sample64** getChannelBuffers (AudioBusBuffers&amp; buffer)
{
    return buffer.channelBuffers64;
}
</code></pre>
<p>Now we can change our <em>doProcessing</em> algorithm to use these functions:</p>
<pre><code class="language-c++">template &lt;SymbolicSampleSizes SampleSize&gt;
void MyEffect::process (ProcessData&amp; data)
{
    ProcessDataSlicer slicer (8);
    
    auto doProcessing = [this] (ProcessData&amp; data) {
        // get the gain value for this block
        ParamValue gain = gainParameter.advance (data.numSamples);

        // process audio
        AudioBusBuffers* inputs = data.inputs;
        AudioBusBuffers* outputs = data.outputs;
        for (auto channelIndex = 0; channelIndex &lt; inputs[0].numChannels; ++channelIndex)
        {
            auto inputBuffers = getChannelBuffers&lt;SampleSize&gt; (inputs[0])[channelIndex];
            auto outputBuffers = getChannelBuffers&lt;SampleSize&gt; (outputs[0])[channelIndex];
            for (auto sampleIndex = 0; sampleIndex &lt; data.numSamples; ++sampleIndex)
            {
                auto sample = inputBuffers[sampleIndex];
                outputBuffers[sampleIndex] = sample * gain;
            }
        }
    };
    
    slicer.process&lt;SampleSize&gt; (data, doProcessing);
}
</code></pre>
<p>As a final step, we now need to call the templated <em>process&lt;...&gt;</em> function from the normal <em>process</em> function:</p>
<pre><code class="language-c++">void MyEffect::process (ProcessData&amp; data)
{
    handleParameterChanges (data.inputParameterChanges);

    if (processSetup.symbolicSampleSize == SymbolicSampleSizes::kSample32)
        process&lt;SymbolicSampleSizes::kSample32&gt; (data);
    else
        process&lt;SymbolicSampleSizes::kSample64&gt; (data);
    
    gainParameter.endChanges ();
}
</code></pre>
<p>Depending on the <em>processSetup.symbolicSampleSize</em> we either call the 32 bit <em>process</em> function or the 64 bit <em>process</em> function.</p>
<p>We just have to inform the host that we can process 64 bit:</p>
<pre><code class="language-c++">tresult PLUGIN_API MyEffect::canProcessSampleSize (int32symbolicSampleSize)
{
    return (symbolicSampleSize == SymbolicSampleSizes::kSample32 ||
            symbolicSampleSize == SymbolicSampleSizes::kSample64) ?
            kResultTrue :
            kResultFalse;
}
</code></pre>
<p>Now we have sample-accurate parameter changes and 32 and 64 bit audio processing.</p>
<hr />
<h2 id="part-3-thread-safe-state-changes"><a class="header" href="#part-3-thread-safe-state-changes">Part 3: Thread safe state changes</a></h2>
<p>One common issue in this domain is that the plug-in state coming from a preset or a DAW project is set by the host from a non realtime thread.</p>
<p>If we want to change our internal data model to use this state, we have to transfer this state to the realtime thread. This should be done in a realtime thread safe manner. Otherwise the model may not reflect the correct state, as parameter changes dispatched in the realtime thread and the state data set on another thread will end in an undefined state.</p>
<p>For this case, we have another utility class: <em>RTTransferT</em></p>
<p>This class expects to have a template parameter <em>StateModel</em> describing the state data. We create a simple struct as a data model:</p>
<pre><code class="language-c++">struct StateModel
{
    double gain;
};

using RTTransfer = RTTransferT&lt;StateModel&gt;;
</code></pre>
<p>We use <em>RTTransfer</em> now as a member for our <em>MyEffect</em> class:</p>
<pre><code class="language-c++">class MyEffect : ....
{
    RTTransfer stateTransfer;
};
</code></pre>
<p>If we now get a new <em>state</em> from the host, we create a <em>newStateModel</em> and write the <em>stateGain</em> value into <em>model-&gt;gain</em> and pass it to the utility class <em>stateTransfer</em>:</p>
<pre><code class="language-c++">tresult PLUGIN_API MyEffect::setState (IBStream* state)
{
    double stateGain = ... // read this out of the state stream
    
    StateModel model = std::make_unique&lt;StateModel&gt; ();
    model-&gt;gain = stateGain;
    
    stateTransfer.transferObject_ui (std::move (model));
    
    return kResultTrue;
}
</code></pre>
<p>To get the <em>stateModel</em> into our realtime thread, we have to change the <em>process</em> function in the following way:</p>
<pre><code class="language-c++">void MyEffect::process (ProcessData&amp; data)
{
    stateTransfer.accessTransferObject_rt ([this] (const auto&amp; stateModel) {
        gainParameter.setValue (stateModel.gain);
    });
    
    handleParameterChanges (data.inputParameterChanges);

    if (processSetup.symbolicSampleSize == SymbolicSampleSizes::kSample32)
        process&lt;SymbolicSampleSizes::kSample32&gt; (data);
    else
        process&lt;SymbolicSampleSizes::kSample64&gt; (data);
    
    gainParameter.endChanges ();
    return kResultTrue;
}
</code></pre>
<p>The <em>accessTransferObject_rt</em> function will check if there is a new model state. If this is the case, it will call the lambda, and then we can set our <em>gainParameter</em> to the value of <em>stateModel.gain</em>.</p>
<p>To free up the memory in the <em>stateTransfer</em> object, we have to call the <em>clear_ui</em> method of it. In this case, where we only have one double as state model, it is OK to hold onto it until the next state is set or the effect is terminated. So we just add it to the <em>terminate</em> method of the plug-in:</p>
<pre><code class="language-c++">tresult PLUGIN_API MyEffect::terminate ()
{
    stateTransfer.clear_ui ();
    return AudioEffect::terminate ();
}
</code></pre>
<p>If the model data uses more memory and you want to get rid of it in advance, use a timer or something similar to call the clear_ui method a little bit after the setState method was called. But this is not the scope of this tutorial.</p>
<p>If you want to use the utility classes, you will find them in the sdk at:</p>
<p><em>public.sdk/source/vst/utility/processdataslicer.h</em><br />
<em>public.sdk/source/vst/utility/sampleaccurate.h</em><br />
<em>public.sdk/source/vst/utility/rttransfer.h</em></p>
<p>That´s it!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../pages/Tutorials/Data+Exchange.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../pages/Tutorials/How+to+use+the+silence+flags.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>

            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../pages/Tutorials/Data+Exchange.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../pages/Tutorials/How+to+use+the+silence+flags.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>
            
            <div id="footer" class="footer">
                <!-- Here comes the footer when available -->
                © 2024 <a href="https://www.steinberg.net" target="_blank">Steinberg Media Technologies GmbH</a>.&nbsp; All rights reserved.&nbsp;&nbsp;&nbsp;&nbsp;
                <a href="https://o.steinberg.net/en/extras/about.html" target="_blank">About</a> |
                <a href="https://o.steinberg.net/en/extras/privacy_policy.html" target="_blank">Privacy Policy</a> |
                <a href="https://o.steinberg.net/en/extras/terms_conditions.html" target="_blank">Legal Terms</a> 
            </div>
        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../mermaid.min.js"></script>
        <script src="../../mermaid-init.js"></script>


    </div>
    </body>
</html>
